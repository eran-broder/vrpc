(function() {
  var EventEmitter, PipeEmitter, crypto, net,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  crypto = require('crypto');

  EventEmitter = require('events').EventEmitter;

  net = require('net');

  module.exports = {
    listen: function(pipeName) {
      return new PipeEmitter(pipeName, false, true);
    },
    connect: function(pipeName) {
      return new PipeEmitter(pipeName, true, true);
    }
  };

  PipeEmitter = (function(superClass) {
    extend(PipeEmitter, superClass);

    PipeEmitter.prototype.clients = {};

    function PipeEmitter(pipeName1, listenOnSub, listen) {
      var hash;
      this.pipeName = pipeName1;
      this.listenOnSub = listenOnSub;
      this.listen = listen;
      PipeEmitter.__super__.constructor.apply(this, arguments);
      this.pipeAddress = "\\\\.\\pipe\\" + this.pipeName;
      if (this.listenOnSub) {
        hash = crypto.createHash('sha1');
        hash.update(process.hrtime().toString());
        this.subKey = hash.digest('hex');
      }
      if (this.listen) {
        this.listenToPipe();
      }
    }

    PipeEmitter.prototype.listenToPipe = function() {
      this.listenPipe = net.createServer((function(_this) {
        return function(stream) {
          return _this.createStream(stream);
        };
      })(this));
      if (this.listenOnSub) {
        this.send('npmsg:connect-to-subkey', this.subKey);
        return this.listenPipe.listen(this.pipeAddress + "-" + this.subKey);
      } else {
        return this.listenPipe.listen(this.pipeAddress);
      }
    };

    PipeEmitter.prototype.createStream = function(stream) {
      return stream.on('data', (function(_this) {
        return function(str) {
          return _this.handleWrite(str);
        };
      })(this));
    };

    PipeEmitter.prototype.handleWrite = function(str) {
      var obj;
      obj = JSON.parse(str.toString());
      obj["arguments"].unshift(obj.event);
      if (obj.subKey) {
        return this.handleMessageFromClient(obj);
      } else {
        return this.emit.apply(this, obj["arguments"]);
      }
    };

    PipeEmitter.prototype.send = function() {
      var args, event, obj, pipe;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      obj = {
        event: event,
        "arguments": args
      };
      if (this.subKey) {
        obj.subKey = this.subKey;
      }
      pipe = net.connect(this.pipeAddress);
      pipe.write(JSON.stringify(obj));
      return pipe.end();
    };

    PipeEmitter.prototype.handleMessageFromClient = function(obj) {
      if (!this.clients[obj.subKey]) {
        this.clients[obj.subKey] = new PipeEmitter(this.pipeName + "-" + obj.subKey, false, false);
      }
      if (obj.event === 'npmsg:connect-to-subkey') {
        return this.emit('connect', this.clients[obj.subKey]);
      } else {
        return this.clients[obj.subKey].emit.apply(this.clients[obj.subKey], obj["arguments"]);
      }
    };

    return PipeEmitter;

  })(EventEmitter);

}).call(this);
